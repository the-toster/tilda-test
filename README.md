# Несколько простых задач, для понимания моего подхода к разработке

Оригинал задания расположен тут - https://task4developer.tilda.ws/backend-easy-task

* [Задача 1: лесенка](#Задача-1:-лесенка)
* [Задача 2: массивы](#Задача-2:-массивы)
* [Задача 3: фронт](#Задача-3:-фронт)

## Отражение подхода

По обыкновению начал с затаскивания в проект основных рабочих инструментов &mdash; `phpunit` и `paslm`.  
Потом идет `README.md`, всегда помогает направить размышления и занять сторону потребителя.
Я постарался изложить в этом ридми свои решения и мотивацию стоящую за ними, рассматривая задачи как свои обычные
рабочие.

## Тесты

Предпочитаю писать в underscore нотации, чтобы получать красивый вывод с флагом `--testdox`, полюбоваться можно так:

```shell
composer run test
```

## Задача 1: лесенка

Нужно вывести лесенкой числа от 1 до 100.

```
 1
 2 3
 4 5 6
 ...
 ```

Пример работы решения можно получить запустив `show_stairs.php`:

```shell
php show_stairs.php
```

Решение реализованно в виде value-object'а `App\Stairs`. `VO` наделяет данные смыслами из предметной области,
типизирует, их удобно тестировать, и, как показывает практика, даже у самых простых данных есть поведение &mdash;
например лесенка умеет представляться в виде строки.

Интерфейс лесенки:

```php
App\Stairs::buildTo(6) // именованный конструктор, это обширная тема, почему именно так
    ->asString();      // получаем строковое представление, магия __toString() - это магия, поэтому - нет
```

## Задача 2: массивы

Нужно заполнить массив 5 на 7 случайными уникальными числами от 1 до 1000.  
Вывести получившийся массив и суммы по строкам и по столбцам.

Пример работы решения:

```php
php show_array.php
```

Код можно увидеть в модуле `App\Matrix`.  
Условия задачи позволяют отразить применяемый мной подход по разделению чистого и IO кода, позаимствованный у
Маттиаса Нобака, из его замечательной
книги [Advanced Web Application Architecture](https://leanpub.com/web-application-architecture/).
<details>
<summary>О подходе и его результатах</summary>

Суть подхода заключается в явном разделении на логическом и физическом уровне кода предметной области (чистого)
и кода инфраструктурного (IO), и контроля направления зависимостей.

- На логическом уровне, я следую правилу, что мои сущности, доменные сервисы, объекты-значения и DTO &mdash; чистые.
- Под физическим разделением я имею в виду раскладывание кода по папочкам. Внутри модуля всё IO я складываю
  в `Infrastructure`.
- Контроль направления зависимостей подразумевает запрет на зависимость от инфраструктуры.

Так же, кроме разделения на чистый / не чистый код, использую разделение чистого кода на 2 вида объектов.  
Грубо говоря, `сервисы` и `доменные объекты` (хотя они и те и те доменные конечно). Это опять же наработка Нобака,
озвученная в другой его прекрасной книге
[Object Design Style Guide](https://www.manning.com/books/object-design-style-guide).

`Сервисы` это stateless объекты для манипуляции со вводом и доменными объектами, под `доменными объектами` понимаются
объекты для хранения состояния (естественно, и поведение и инварианты остаются в них).
Сущности, VO, DTO. Для этой пары так же действует естественное правило для направления зависимостей и другие интересные
закономерности.

В результате применения такого подхода, код удовлетворяет луковой (и гексагональной) архитектуре:
в центре находятся `доменные объекты`, вокруг `сервисы`, и на внешнем уровне - инфраструктура.

</details>

Источник случайности в данной задаче &mdash; классический пример IO.
Поэтому он отделяется интерфейсом, что позволяет тестировать используя детерминированную реализацию.

<details>
    <summary>Неочевидный момент в объекте матрицы</summary>

Для подсчета сумм, используется транспонирование, элегантный способ построения
которого был получен
со [stackoverflow](https://stackoverflow.com/questions/797251/transposing-multidimensional-arrays-in-php):
и сначала выглядел примерно так:

```php
    public function transpose(): self
    {
        return new self(array_map($callback, ...$this->rows));
    }
```

Это работает, потому что `array_map()` при пустом колбэке
выполняет [`zip` над остальными аргументами](https://www.php.net/manual/en/function.array-map.php).  
Операция `zip` берет два списка и превращает их в один список пар. Или три списка в один список троек. И т.д.  
_(Мне она знакома из начального курса хаскеля - да, я рисуюсь, это же тестовое задание))_

Как выяснилось, это элегантное транспонирование не работает для однострочной матрицы, что логично:

```php
array_map(null, ...[[1, 2, 3]])
// превращается в
array_map(null, [1, 2, 3])
// зиповать не с чем, получаем вектор вместо матрицы
[1, 2, 3]
```

Поэтому в итоге однострочная матрица обрабатываться как особый случай, другим колбэком.
</details>

Для рисования таблички с матрицей я взял малоизвестную библиотеку, но она поддерживается и основана
на `laminas/laminas-text`,
(это бывший `zendframework/zend-text`) то есть, определенное доверие к ней есть. Тащить сюда `symfony/console` я не
стал)).

## Задача 3: фронт

Задача 3: фронт
> Вы работаете в компании, присутствующей в нескольких городах РФ. На сайте компании есть страница с контактной
> информацией. Маркетолог поставил задачу и уехал, к его приезду задача должна быть реализована.
>
> На страницу контактов заходят люди из разных городов, нужно чтобы они видели телефон из своего города. По умолчанию,
> в HTML-страницы прописан телефон 8-800-DIGITS. Телефон размещен в верху и внизу страницы.
>
> Вот и все что рассказал маркетолог прежде чем уехать.

Из этого описания можно выделить две задачи

- определять город посетителя
- подменять телефон на странице

А они наводят на мысли о последующих - управлении маппингом телефонов, правилах фолбэка и поведения для поисковика
&mdash; это явно потребует консультаций со всеми заинтересованными лицами, а первые две все равно необходимы,
сосредоточимся на них.

### Определять город посетителя

Три очевидных направления доступны здесь:

- геолокация
- географическая база IP адресов.
- спросить у посетителя

Геолокация дает высокоточный результат в координатах, но:

- требует беспокоить пользователя,
- должна поддерживаться устройством,
- координаты надо превратить в город - а отдельная нетривиальная задача

Географические базы в свою очередь дают намного менее точный результат, но не предъявляют никаких требований к
пользователю и на выходе уже готовый город (или его отсутствие).

Спросить у пользователя требует внимания посетителя, дает отличную точность и имеет определенную нами область значения
результата. Однако, в зависимости от обширности нашей географии, сам процесс выбора может быть довольно обременительным
для пользователя.

Исходя из сказанного, и принимая во внимание распространенный UX паттерн "подтвердите ваш город", я выбрал комбинацию
базы и вопроса пользователю.

Запрос к географической базе может быть выполнен и на бэке и на фронте.

### Подменять телефон на странице
Менять телефон можно так же, и на бэке и на фронте. Т.к. существует возможность выбора города посетителем на странице,
желательно делать это без перезагрузки страницы (ну и принимая во внимание название задачи)).

### Итоговое решение
Сделаем все на фронте &mdash; условия позволяют, и фичу сохраним более концентрированной, и лишний стейт
(в клиент-серверном) не породим.

В качестве источника данных о городе возьмем АПИ Яндекс Карт.
